option Casing = Snake
option TypesOutput = "../src/types/remotes.luau"
option ServerOutput = "../src/server/serverevents.luau"
option ClientOutput = "../src/common/clientevents.luau"
option Typescript = false
option FutureLibrary = "ReplicatedStorage.pkg.future"
-- this is a comment

option WriteValidations = false
option SyncValidation = false

type Entity = f64
type Model = Instance(Model)?

scope Building {
  --[[
    This event is used to let the server know that the client wants to teleport to either
    the interior or the exterior of the house. If the Housetype that they sent is interior, it
    means the player is currently in interior, and so the server should then send them to exterior
    and vice versa
    @params Entity the server entity id of the parent house that contains Interior/Exterior
    @params HouseType the type of the current house they player is near at
  ]]
  enum HouseType = {interior, exterior}
  event IWantToTeleportInOrOut {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity, HouseType)
  }

  --[[
    This event is used to mark a house as having a cutscene, in particular, the doormat would have
    the HasCutscene entity. We only fire this event to client after we have verified that client
    has picked up the order from Restaurant. Then when they are near the house, we want to play
    the cutscene. In future, users can configure what cutscene they want others to see so we would
    pass this data to the client

    @params Entity the server entity if of the house that will render the cutscene
  ]]
  event add_cutscene_to_house {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }


  --[[
    TODO: The following events, we want to deprecate in future and instead opt to use Attributes
    Attributes replicate from server -> client, so instead, what we will do is that InteriorModel
    will contain some collectionservice tag. The client will listen to adding/removal of this tag
    Every interior model is always paired up with its exterior model, and this is also just a one time
    thing. So we can just store exterior model details in its attributes. Reading them, we can
    construct the house from ground up

    The tricky part is just ensuring how we handle the Instance Added and Removed. There are few options
    one of them could be we would lonly delete houses when client tells them to do so, or we would
    only construct house when client tells them to do so as well...
  ]]
  type IsNPC = boolean
  type ExteriorHouseType = string
  event bulk_create_house_owners {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity[0..50], Instance[0..50], IsNPC[0..50])
  }

  event bulk_create_house {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity[0..50], CFrame[0..50], Instance[0..50], ExteriorHouseType[0..50], Entity[0..50])
  }

  event create_house_owner {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity, Instance, IsNPC)
  }

  event create_house {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity, CFrame, Instance, ExteriorHouseType, Entity)
  }

  event delete_house_owner {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }

  event bulk_create_restaurants {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity[0..10], string[0..10], Instance[0..10])
  }
}

scope PlayerEvents {
  event player_loaded_in {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }

  event i_have_loaded_in {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
  }

  event setup_map_on_join {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
  }

  event i_have_setup_map {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
  }

  --[[
    TODO
    idk if we need this but okay....
  ]]

  event i_have_setup_houses {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
  }

  event i_have_setup_restaurants {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
  }

  event i_have_bulk_created_orders_initially {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
  }
}

--[[
  These are the events related to delivering, ordering, and etc.
]]

scope RouberOrders {
  struct DeliveryType {
      restaurant_id: Entity,
      destination_id: Entity,
      foods_list_id: Entity[1..10],
      conditions_list_id: Entity[0..10]
  }

  struct DeliveryRewardType {
    coins: f64,
    gems: f64,
    has_mystery_box: boolean
  }

  event create_order {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity, DeliveryType, DeliveryRewardType)
  }

  event bulk_create_order {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity[0..100], DeliveryType[0..100], DeliveryRewardType[0..100])
  }

  --[[
    This will called whenever an order is invalid and marked as vacant.
  ]]
  event delete_order {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }

    --[[
    This will called whenever a player or NPC's house is replace due to either a player joining
    or leaving. We only fire this order when we have verified that the order is no longer vacant, which
    means someone accepted it. So we fire event to that person to update the order

    Something to note, we should only process this order AFTER create_house is called
    or maybe we can defer it or something idk

    @params Entity, the server order id
    @params Entity, the new server house id
  ]]
  event update_order_address {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity, Entity)
  }

  --[[
    Client sends the mapped server entity id to the server. TBH this might be better off
    being a remote function too ngl...
  ]]
  event i_want_to_accept_order {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }

  --[[
    Basically will send a boolean value first which indicates whether an order was
    successfully claimed or not. If it was claimed, we send back the server_entity id of the
    order

    If not, we send back an error message which we would need to display to client
  ]]
  event accept_order_response {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (boolean, Entity?, string?)
  }

  --[[
    Client is in a restaurant and they are trying to pick up an order. This will be
    a remote function as we want the client to get back a success/failure response if
    an order pickup was successful or not
  ]]
  event i_want_to_pickup_order {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }

  --[[
    We should move the Entity to the next one but for now its ok here. This entity is the
    house entity. We will then need to add cutsfcene component there so
  ]]
  event pickup_order_response {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: ( boolean, Entity?, string?)
  }

  --[[
    Okay this is tricky, if we made a choice, how do we know if it is for a single order
    vs all the orders in a restaurant??
  ]]

  enum OrderChoices = { Deliver, Steal, Tamper }
  event my_choice_for_this_order {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity, OrderChoices)
  }

  --[[
    Here, the entity should represent the house_entity id
  ]]
  event i_want_to_complete_order {
    From: Client,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: Entity
  }

  --[[
    Server just sends a server entity id and foodname so client can setup
  ]]
  event bulk_setup_food {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: (Entity[0..100], string[0..100])
  }
}

scope RouberCurrency {
  event IncreaseCoins {
    From: Server,
    Type: Reliable,
    Call: SingleSync,
    Poll: true,
    Data: f64,
  }
}
